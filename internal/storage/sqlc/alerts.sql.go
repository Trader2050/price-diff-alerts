// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: alerts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const deleteAlertsBefore = `-- name: DeleteAlertsBefore :exec
DELETE FROM alerts
WHERE created_at < $1
`

func (q *Queries) DeleteAlertsBefore(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteAlertsBefore, createdAt)
	return err
}

const insertAlert = `-- name: InsertAlert :one
INSERT INTO alerts (
    sample_ts,
    deviation_pct,
    threshold_pct,
    direction,
    channels
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (sample_ts) DO UPDATE
SET
    deviation_pct = EXCLUDED.deviation_pct,
    threshold_pct = EXCLUDED.threshold_pct,
    direction     = EXCLUDED.direction,
    channels      = EXCLUDED.channels
RETURNING id, sample_ts, deviation_pct, threshold_pct, direction, channels, created_at
`

type InsertAlertParams struct {
	SampleTs     pgtype.Timestamptz `json:"sample_ts"`
	DeviationPct decimal.Decimal    `json:"deviation_pct"`
	ThresholdPct decimal.Decimal    `json:"threshold_pct"`
	Direction    string             `json:"direction"`
	Channels     []string           `json:"channels"`
}

func (q *Queries) InsertAlert(ctx context.Context, arg InsertAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, insertAlert,
		arg.SampleTs,
		arg.DeviationPct,
		arg.ThresholdPct,
		arg.Direction,
		arg.Channels,
	)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.SampleTs,
		&i.DeviationPct,
		&i.ThresholdPct,
		&i.Direction,
		&i.Channels,
		&i.CreatedAt,
	)
	return i, err
}

const listRecentAlerts = `-- name: ListRecentAlerts :many
SELECT
    id,
    sample_ts,
    deviation_pct,
    threshold_pct,
    direction,
    channels,
    created_at
FROM alerts
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListRecentAlerts(ctx context.Context, limit int32) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listRecentAlerts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.SampleTs,
			&i.DeviationPct,
			&i.ThresholdPct,
			&i.Direction,
			&i.Channels,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
