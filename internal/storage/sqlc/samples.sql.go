// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: samples.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countSamples = `-- name: CountSamples :one
SELECT COUNT(*)
FROM rate_samples
`

func (q *Queries) CountSamples(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSamples)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteSamplesBefore = `-- name: DeleteSamplesBefore :exec
DELETE FROM rate_samples
WHERE bucket_ts < $1
`

func (q *Queries) DeleteSamplesBefore(ctx context.Context, bucketTs pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteSamplesBefore, bucketTs)
	return err
}

const listRecentSamples = `-- name: ListRecentSamples :many
SELECT
    bucket_ts,
    official_susde_per_usde,
    market_susde_per_usde,
    deviation_pct,
    notional_usde,
    cow_quality,
    cow_quote,
    block_number,
    status,
    error,
    created_at
FROM rate_samples
ORDER BY bucket_ts DESC
LIMIT $1
`

func (q *Queries) ListRecentSamples(ctx context.Context, limit int32) ([]RateSample, error) {
	rows, err := q.db.Query(ctx, listRecentSamples, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RateSample{}
	for rows.Next() {
		var i RateSample
		if err := rows.Scan(
			&i.BucketTs,
			&i.OfficialSusdePerUsde,
			&i.MarketSusdePerUsde,
			&i.DeviationPct,
			&i.NotionalUsde,
			&i.CowQuality,
			&i.CowQuote,
			&i.BlockNumber,
			&i.Status,
			&i.Error,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSamplesBetween = `-- name: ListSamplesBetween :many
SELECT
    bucket_ts,
    official_susde_per_usde,
    market_susde_per_usde,
    deviation_pct,
    notional_usde,
    cow_quality,
    cow_quote,
    block_number,
    status,
    error,
    created_at
FROM rate_samples
WHERE bucket_ts >= $1
  AND bucket_ts < $2
ORDER BY bucket_ts
`

type ListSamplesBetweenParams struct {
	BucketTs   pgtype.Timestamptz `json:"bucket_ts"`
	BucketTs_2 pgtype.Timestamptz `json:"bucket_ts_2"`
}

func (q *Queries) ListSamplesBetween(ctx context.Context, arg ListSamplesBetweenParams) ([]RateSample, error) {
	rows, err := q.db.Query(ctx, listSamplesBetween, arg.BucketTs, arg.BucketTs_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RateSample{}
	for rows.Next() {
		var i RateSample
		if err := rows.Scan(
			&i.BucketTs,
			&i.OfficialSusdePerUsde,
			&i.MarketSusdePerUsde,
			&i.DeviationPct,
			&i.NotionalUsde,
			&i.CowQuality,
			&i.CowQuote,
			&i.BlockNumber,
			&i.Status,
			&i.Error,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSampleErrored = `-- name: MarkSampleErrored :exec
UPDATE rate_samples
SET status = 'errored', error = $2
WHERE bucket_ts = $1
`

type MarkSampleErroredParams struct {
	BucketTs pgtype.Timestamptz `json:"bucket_ts"`
	Error    pgtype.Text        `json:"error"`
}

func (q *Queries) MarkSampleErrored(ctx context.Context, arg MarkSampleErroredParams) error {
	_, err := q.db.Exec(ctx, markSampleErrored, arg.BucketTs, arg.Error)
	return err
}

const upsertRateSample = `-- name: UpsertRateSample :exec
INSERT INTO rate_samples (
    bucket_ts,
    official_susde_per_usde,
    market_susde_per_usde,
    deviation_pct,
    notional_usde,
    cow_quality,
    cow_quote,
    block_number,
    status,
    error
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT (bucket_ts) DO UPDATE
SET
    official_susde_per_usde = EXCLUDED.official_susde_per_usde,
    market_susde_per_usde   = EXCLUDED.market_susde_per_usde,
    deviation_pct           = EXCLUDED.deviation_pct,
    notional_usde           = EXCLUDED.notional_usde,
    cow_quality             = EXCLUDED.cow_quality,
    cow_quote               = EXCLUDED.cow_quote,
    block_number            = EXCLUDED.block_number,
    status                  = EXCLUDED.status,
    error                   = EXCLUDED.error
`

type UpsertRateSampleParams struct {
	BucketTs             pgtype.Timestamptz `json:"bucket_ts"`
	OfficialSusdePerUsde decimal.Decimal    `json:"official_susde_per_usde"`
	MarketSusdePerUsde   decimal.Decimal    `json:"market_susde_per_usde"`
	DeviationPct         decimal.Decimal    `json:"deviation_pct"`
	NotionalUsde         decimal.Decimal    `json:"notional_usde"`
	CowQuality           string             `json:"cow_quality"`
	CowQuote             []byte             `json:"cow_quote"`
	BlockNumber          pgtype.Int8        `json:"block_number"`
	Status               string             `json:"status"`
	Error                pgtype.Text        `json:"error"`
}

func (q *Queries) UpsertRateSample(ctx context.Context, arg UpsertRateSampleParams) error {
	_, err := q.db.Exec(ctx, upsertRateSample,
		arg.BucketTs,
		arg.OfficialSusdePerUsde,
		arg.MarketSusdePerUsde,
		arg.DeviationPct,
		arg.NotionalUsde,
		arg.CowQuality,
		arg.CowQuote,
		arg.BlockNumber,
		arg.Status,
		arg.Error,
	)
	return err
}
